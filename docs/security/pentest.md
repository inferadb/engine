# InferaDB Authentication Penetration Testing Guide

This guide provides instructions for security researchers and penetration testers to evaluate the security of InferaDB's authentication system.

## Table of Contents

1. [Overview](#overview)
2. [Test Environment Setup](#test-environment-setup)
3. [Attack Vectors](#attack-vectors)
4. [Expected Results](#expected-results)
5. [Reporting](#reporting)

## Overview

InferaDB uses JWT-based authentication with the following features:

-   **Private-Key JWT (RFC 7523)**: For tenant SDK/CLI authentication
-   **OAuth 2.0 Bearer Tokens (RFC 6749)**: For dashboard and enterprise SSO
-   **Internal Service JWT**: For control plane to PDP communication
-   **Asymmetric signatures only**: EdDSA and RS256
-   **Optional replay protection**: Using Redis-backed JTI tracking

## Test Environment Setup

### Prerequisites

```bash
# Clone the repository
git clone https://github.com/inferadb/server
cd server

# Build the server
cargo build --release

# Run with authentication enabled
export INFERADB_AUTH_ENABLED=true
export INFERADB_JWKS_BASE_URL=https://your-test-jwks-endpoint
cargo run --release
```

### Test Configuration

Create a test configuration file (`config.test.toml`):

```toml
[auth]
enabled = true
jwks_base_url = "https://your-test-control-plane/.well-known"
accepted_algorithms = ["EdDSA", "RS256"]
enforce_audience = true
audience = "https://api.inferadb.com/evaluate"
enforce_scopes = true
clock_skew_seconds = 60
max_token_age_seconds = 86400
replay_protection = false  # Enable only if Redis is available
```

### Generate Test JWTs

Use the included JWT generation tools:

```bash
# Generate a valid tenant JWT
cargo run --bin generate-tenant-jwt -- \
  --tenant acme \
  --scopes "inferadb.check inferadb.write" \
  --key-file test-keys/tenant-acme.pem

# Generate an internal service JWT
cargo run --bin generate-internal-jwt -- \
  --issuer "https://internal.inferadb.com" \
  --key-file test-keys/internal.pem
```

## Attack Vectors

### 1. JWT Algorithm Confusion Attack

**Objective**: Attempt to bypass signature verification using algorithm confusion.

#### Test 1.1: "none" Algorithm

```bash
# Generate a JWT with alg="none"
TOKEN="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJ0ZW5hbnQ6YWNtZSIsInN1YiI6ImF0dGFja2VyIiwiYXVkIjoiaW5mZXJhZGIiLCJleHAiOjk5OTk5OTk5OTksImlhdCI6MTYwMDAwMDAwMCwic2NvcGUiOiJpbmZlcmFkYi5jaGVjayBpbmZlcmFkYi53cml0ZSJ9."

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Unsupported algorithm: none"`

#### Test 1.2: Symmetric Algorithm (HS256)

```bash
# Create a token signed with HS256 using a known secret
# (Use jwt.io or pyjwt to generate)
TOKEN="<HS256-signed-token>"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Unsupported algorithm: HS256"`

#### Test 1.3: Algorithm Swapping (RS256 â†’ HS256)

Attempt to use the public key as an HS256 secret:

```python
import jwt
import requests

# Fetch the public key
jwks_response = requests.get("https://your-jwks-endpoint/.well-known/jwks.json")
public_key_pem = extract_public_key(jwks_response.json())

# Try to sign with public key as HS256 secret
payload = {
    "iss": "tenant:acme",
    "sub": "attacker",
    "aud": "inferadb",
    "exp": 9999999999,
    "iat": 1600000000,
    "scope": "inferadb.check inferadb.write"
}

token = jwt.encode(payload, public_key_pem, algorithm="HS256")

# Send the token
response = requests.post(
    "http://localhost:8080/v1/check",
    headers={"Authorization": f"Bearer {token}"},
    json={"namespace": "test", "tuples": []}
)

print(response.status_code, response.text)
```

**Expected Result**: `401 Unauthorized` - symmetric algorithms are blocked regardless of key material

### 2. Expired Token Acceptance

**Objective**: Verify that expired tokens are properly rejected.

#### Test 2.1: Recently Expired Token

```bash
# Generate a token that expired 5 minutes ago
TOKEN="<expired-token-5min-ago>"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Token expired"`

#### Test 2.2: Token Within Clock Skew

```bash
# Generate a token that expired 30 seconds ago (within 60s clock skew)
TOKEN="<expired-token-30s-ago>"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `200 OK` - within clock skew tolerance

### 3. Token Replay Attacks

**Objective**: Verify replay protection (if enabled).

#### Test 3.1: Token Reuse (Replay Protection Disabled)

```bash
TOKEN="<valid-token>"

# First request
curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'

# Second request (replay)
curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result (if replay protection disabled)**: Both requests succeed with `200 OK`

**Expected Result (if replay protection enabled)**: First request `200 OK`, second request `401 Unauthorized` with error `"Token replay detected"`

#### Test 3.2: JTI Missing (Replay Protection Enabled)

```bash
# Generate a token without jti claim when replay protection is enabled
TOKEN="<token-without-jti>"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Missing claim: jti"`

### 4. Missing Signature Validation

**Objective**: Ensure signature verification cannot be bypassed.

#### Test 4.1: Invalid Signature

```bash
# Take a valid token and modify the signature
VALID_TOKEN="eyJhbGc...validtoken..."
# Change last character of signature
INVALID_TOKEN="${VALID_TOKEN:0:-1}X"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $INVALID_TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Invalid signature"`

#### Test 4.2: Modified Claims

```bash
# Take a valid token, decode the payload, modify a claim, re-encode without re-signing
# Example: Change tenant ID from "acme" to "admin"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $MODIFIED_TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Invalid signature"`

### 5. SQL Injection in Claims

**Objective**: Verify that JWT claims don't enable SQL injection (not applicable to InferaDB as it's not SQL-based).

This test is **not applicable** as InferaDB does not use SQL databases. Claims are used for authorization only, not query construction.

### 6. Cross-Tenant Access

**Objective**: Verify tenant isolation is enforced.

#### Test 6.1: Wrong Tenant ID

```bash
# Generate a valid token for tenant "acme"
ACME_TOKEN="<valid-acme-token>"

# Try to access data for tenant "globex"
curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $ACME_TOKEN" \
  -H "X-Tenant-Id: globex" \
  -d '{"namespace": "globex:data", "tuples": []}'
```

**Expected Result**: `403 Forbidden` or tenant isolation enforced (exact behavior depends on authorization layer)

#### Test 6.2: Tenant ID Claim Modification

```bash
# Attempt to create a token with tenant_id="admin" using a valid key for tenant="acme"
# This should fail at signature verification since the tenant-specific key won't match

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $FORGED_TOKEN" \
  -d '{"namespace": "admin:data", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Invalid signature"` or `"Key not found in JWKS"`

### 7. Scope Escalation

**Objective**: Verify that scope validation prevents unauthorized actions.

#### Test 7.1: Missing Required Scope

```bash
# Generate a token with only "inferadb.read" scope
READ_ONLY_TOKEN="<read-only-token>"

# Try to write data
curl -X POST http://localhost:8080/v1/write \
  -H "Authorization: Bearer $READ_ONLY_TOKEN" \
  -d '{"namespace": "test", "tuples": [...]}'
```

**Expected Result**: `403 Forbidden` with error `"Invalid scope: inferadb.write required"`

#### Test 7.2: Wildcard Scope Abuse

```bash
# Try to use "*" or "inferadb.*" as a scope
WILDCARD_TOKEN="<token-with-wildcard-scope>"

curl -X POST http://localhost:8080/v1/admin/delete-all \
  -H "Authorization: Bearer $WILDCARD_TOKEN"
```

**Expected Result**: `403 Forbidden` - wildcards should not grant elevated privileges

### 8. Token Length Attacks

**Objective**: Test system behavior with excessively large tokens.

#### Test 8.1: Very Long Token

```bash
# Generate a token with a very long payload (> 100KB)
HUGE_TOKEN="<extremely-long-token>"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $HUGE_TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `400 Bad Request` or `413 Payload Too Large` (server should not crash)

### 9. Malformed JWT Handling

**Objective**: Ensure malformed JWTs don't cause crashes.

#### Test 9.1: Invalid Base64 Encoding

```bash
TOKEN="not.valid.base64@@@@"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Invalid token format"` (no crash)

#### Test 9.2: Missing Parts

```bash
TOKEN="only.two.parts"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"JWT must have 3 parts"` (no crash)

#### Test 9.3: Invalid JSON in Claims

```bash
# Valid base64 but invalid JSON in payload
TOKEN="eyJhbGciOiJFZERTQSJ9.aW52YWxpZC1qc29u.signature"

curl -X POST http://localhost:8080/v1/check \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"namespace": "test", "tuples": []}'
```

**Expected Result**: `401 Unauthorized` with error `"Failed to parse JWT claims"` (no crash)

## Expected Results Summary

| Attack Vector               | Expected Result                             |
| --------------------------- | ------------------------------------------- |
| "none" algorithm            | `401 Unauthorized` - Algorithm blocked      |
| HS256 symmetric             | `401 Unauthorized` - Algorithm blocked      |
| Expired token               | `401 Unauthorized` - Token expired          |
| Token replay (when enabled) | `401 Unauthorized` - Replay detected        |
| Invalid signature           | `401 Unauthorized` - Signature invalid      |
| Modified claims             | `401 Unauthorized` - Signature invalid      |
| Cross-tenant access         | `403 Forbidden` - Tenant isolation enforced |
| Scope escalation            | `403 Forbidden` - Insufficient scope        |
| Malformed JWT               | `401 Unauthorized` - No crash               |

## Reporting Security Issues

### Responsible Disclosure

If you discover a vulnerability:

1. **Do not** publicly disclose the issue before we've had time to address it
2. Email **security@inferadb.com** with:
    - Detailed description of the vulnerability
    - Steps to reproduce
    - Proof of concept (if available)
    - Your contact information

### What to Include in Your Report

-   **Vulnerability type**: e.g., "JWT Algorithm Confusion"
-   **Severity**: Critical / High / Medium / Low
-   **Prerequisites**: What conditions are needed to exploit
-   **Impact**: What an attacker could achieve
-   **Steps to reproduce**: Detailed walkthrough
-   **Proof of concept**: Code, curl commands, or screenshots
-   **Remediation suggestions**: How to fix (if known)

### Response Timeline

-   **Within 48 hours**: Initial response acknowledging receipt
-   **Within 7 days**: Triage and severity assessment
-   **Within 30 days**: Fix for high/critical issues
-   **Within 90 days**: Fix for medium/low issues

### Bug Bounty

We currently **do not** have a bug bounty program, but we will:

-   Credit you in our security advisory (with your permission)
-   Thank you publicly in our release notes
-   Provide InferaDB swag or credits (for significant findings)

## Testing Tools

### Recommended Tools

-   **JWT.io**: For JWT inspection and manipulation
-   **Burp Suite**: For request interception and modification
-   **curl**: For command-line API testing
-   **Postman**: For API testing with collections
-   **jwt-cli**: Command-line JWT manipulation tool

### Custom Testing Scripts

See the `tests/pentest/` directory for ready-to-use scripts:

```bash
# Run all penetration tests
cargo run --bin run-pentest-suite

# Run specific test category
cargo run --bin run-pentest-suite -- --category algorithm-confusion
```

## Further Reading

-   [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
-   [JWT Security Best Practices](https://tools.ietf.org/html/rfc8725)
-   [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics)

## Contact

-   **Security Team**: security@inferadb.com
-   **General Support**: support@inferadb.com
-   **GitHub Issues**: https://github.com/inferadb/server/issues
